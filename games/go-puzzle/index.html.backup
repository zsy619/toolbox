<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›´æ£‹æ­»æ´»é¢˜ - å›´æ£‹è®­ç»ƒæ¸¸æˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #DEB887 0%, #F4A460 50%, #CD853F 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .game-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            max-width: 1000px;
            width: 100%;
        }
        h1 {
            text-align: center;
            color: #8B4513;
            margin-bottom: 20px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .info-card {
            background: #FFF8DC;
            padding: 12px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid #DEB887;
        }
        .info-label {
            color: #8B4513;
            font-size: 0.9rem;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .info-value {
            color: #4A4A4A;
            font-size: 1.2rem;
            font-weight: bold;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            background: #8B4513;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        button:hover {
            background: #A0522D;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .game-board {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin: 20px 0;
            min-height: 600px;
        }
        .go-board-container {
            background: #DEB887;
            border-radius: 15px;
            padding: 20px;
            border: 3px solid #8B4513;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .go-board {
            width: 450px;
            height: 450px;
            background: #DEB887;
            position: relative;
            display: grid;
            grid-template-columns: repeat(11, 1fr);
            grid-template-rows: repeat(11, 1fr);
        }
        .go-cell {
            border: 1px solid #8B4513;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .go-cell:hover {
            background: rgba(255, 215, 0, 0.3);
        }
        .go-cell.last-move {
            background: rgba(255, 0, 0, 0.3);
        }
        .go-stone {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .go-stone.black {
            background: radial-gradient(circle at 30% 30%, #666, #111);
            color: white;
        }
        .go-stone.white {
            background: radial-gradient(circle at 30% 30%, #fff, #ddd);
            color: black;
            border: 1px solid #ccc;
        }
        .go-stone:hover {
            transform: scale(1.1);
        }
        .control-panel {
            background: #FFF8DC;
            border-radius: 15px;
            padding: 15px;
            border: 2px solid #DEB887;
        }
        .section-title {
            text-align: center;
            color: #8B4513;
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        .puzzle-info {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid #DEB887;
        }
        .puzzle-title {
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        .puzzle-description {
            color: #666;
            line-height: 1.5;
            margin-bottom: 10px;
        }
        .puzzle-type {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
        }
        .type-life { background: #32CD32; }
        .type-death { background: #DC143C; }
        .type-tesuji { background: #4169E1; }
        .move-sequence {
            background: white;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            max-height: 150px;
            overflow-y: auto;
            border: 2px solid #DEB887;
        }
        .move-entry {
            padding: 5px;
            margin: 2px 0;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        .move-entry:nth-child(even) {
            background: #F5F5F5;
        }
        .move-entry.black { color: #333; }
        .move-entry.white { color: #666; }
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .action-btn {
            background: #DEB887;
            color: #8B4513;
            border: 2px solid #8B4513;
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .action-btn:hover {
            background: #8B4513;
            color: white;
            transform: translateY(-1px);
        }
        .territory-display {
            background: white;
            border-radius: 10px;
            padding: 10px;
            margin-top: 15px;
            border: 2px solid #DEB887;
        }
        .territory-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            border-radius: 5px;
        }
        .territory-black { background: #f0f0f0; color: #333; }
        .territory-white { background: #f8f8f8; color: #666; }
        .puzzle-list {
            background: white;
            border-radius: 10px;
            padding: 10px;
            margin-top: 15px;
            border: 2px solid #DEB887;
            max-height: 200px;
            overflow-y: auto;
        }
        .puzzle-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid #DDD;
        }
        .puzzle-item:hover {
            background: #F0F8FF;
            transform: scale(1.02);
        }
        .puzzle-item.current {
            background: #FFE4B5;
            border-color: #DEB887;
        }
        .puzzle-item.solved {
            background: #E6FFE6;
            border-color: #32CD32;
        }
        .success-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .success-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            animation: successPop 0.5s ease-out;
            border: 3px solid #8B4513;
        }
        @keyframes successPop {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .coordinate-labels {
            position: absolute;
            font-size: 0.8rem;
            color: #8B4513;
            font-weight: bold;
        }
        .coord-top, .coord-bottom {
            display: flex;
            justify-content: space-around;
            width: 100%;
        }
        .coord-left, .coord-right {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 100%;
        }
        .coord-top { top: -20px; }
        .coord-bottom { bottom: -20px; }
        .coord-left { left: -20px; }
        .coord-right { right: -20px; }
        @media (max-width: 768px) {
            .game-container { padding: 15px; }
            h1 { font-size: 2rem; }
            .game-board { grid-template-columns: 1fr; gap: 15px; }
            .go-board { width: 300px; height: 300px; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr); }
            .go-stone { width: 20px; height: 20px; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>âš« å›´æ£‹æ­»æ´»é¢˜ âšª</h1>
        
        <div class="game-info">
            <div class="info-card">
                <div class="info-label">é¢˜ç›®</div>
                <div class="info-value" id="currentPuzzle">1</div>
            </div>
            <div class="info-card">
                <div class="info-label">æ‰‹æ•°</div>
                <div class="info-value" id="moveCount">0</div>
            </div>
            <div class="info-card">
                <div class="info-label">ç”¨æ—¶</div>
                <div class="info-value" id="solveTime">00:00</div>
            </div>
            <div class="info-card">
                <div class="info-label">å®Œæˆ</div>
                <div class="info-value" id="solvedCount">0/15</div>
            </div>
        </div>

        <div class="controls">
            <button onclick="goPuzzle.resetPuzzle()">é‡ç½®</button>
            <button onclick="goPuzzle.undoMove()" id="undoBtn" disabled>æ‚”æ£‹</button>
            <button onclick="goPuzzle.showHint()">æç¤º</button>
            <button onclick="goPuzzle.checkSolution()">æ£€æŸ¥ç­”æ¡ˆ</button>
            <button onclick="goPuzzle.showRules()">æ¸¸æˆè§„åˆ™</button>
        </div>

        <div class="game-board">
            <div class="go-board-container">
                <div class="go-board" id="goBoard">
                    <div class="coordinate-labels coord-top">
                        <span>A</span><span>B</span><span>C</span><span>D</span><span>E</span><span>F</span><span>G</span><span>H</span><span>J</span><span>K</span><span>L</span>
                    </div>
                    <div class="coordinate-labels coord-left">
                        <span>11</span><span>10</span><span>9</span><span>8</span><span>7</span><span>6</span><span>5</span><span>4</span><span>3</span><span>2</span><span>1</span>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <div class="puzzle-info">
                    <div class="puzzle-title" id="puzzleTitle">åŸºç¡€æ­»æ´»</div>
                    <div class="puzzle-description" id="puzzleDescription">é»‘å…ˆï¼Œäº‰å–åšæ´»</div>
                    <div class="puzzle-type type-life" id="puzzleType">åšæ´»é¢˜</div>
                </div>

                <div class="move-sequence">
                    <h4 style="color: #8B4513; margin-bottom: 10px;">ç€æ‰‹è®°å½•</h4>
                    <div id="moveSequence"></div>
                </div>

                <div class="action-buttons">
                    <button class="action-btn" onclick="goPuzzle.nextPuzzle()">ä¸‹ä¸€é¢˜</button>
                    <button class="action-btn" onclick="goPuzzle.previousPuzzle()">ä¸Šä¸€é¢˜</button>
                    <button class="action-btn" onclick="goPuzzle.randomPuzzle()">éšæœºé¢˜ç›®</button>
                    <button class="action-btn" onclick="goPuzzle.analyzePosition()">å½¢åŠ¿åˆ†æ</button>
                </div>

                <div class="territory-display">
                    <h4 style="color: #8B4513; margin-bottom: 10px;">ç›®æ ‡åˆ†æ</h4>
                    <div id="territoryInfo">
                        <div class="territory-item">
                            <span>ç›®æ ‡ï¼š</span>
                            <span id="puzzleGoal">åšæ´»é»‘æ£‹</span>
                        </div>
                        <div class="territory-item">
                            <span>éš¾åº¦ï¼š</span>
                            <span id="puzzleDifficulty">â˜…â˜…â˜†</span>
                        </div>
                    </div>
                </div>

                <div class="puzzle-list">
                    <h4 style="color: #8B4513; margin-bottom: 10px;">é¢˜ç›®åˆ—è¡¨</h4>
                    <div id="puzzleList"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="success-modal" id="successModal">
        <div class="success-content">
            <h2>ğŸ‰ è§£ç­”æ­£ç¡®ï¼ğŸ‰</h2>
            <p id="successText"></p>
            <div style="margin: 20px 0;">
                <p>ç”¨æ—¶: <span id="finalTime">00:00</span></p>
                <p>æ‰‹æ•°: <span id="finalMoves">0</span></p>
            </div>
            <button onclick="goPuzzle.closeSuccessModal()">ä¸‹ä¸€é¢˜</button>
            <button onclick="goPuzzle.closeSuccessModal(); goPuzzle.resetPuzzle();">å†åšä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        class GoPuzzleGame {
            constructor() {
                this.currentPuzzleIndex = 0;
                this.board = Array(11).fill(null).map(() => Array(11).fill(0)); // 0=ç©º, 1=é»‘, 2=ç™½
                this.moveHistory = [];
                this.startTime = Date.now();
                this.solvedPuzzles = new Set(JSON.parse(localStorage.getItem('solvedGoPuzzles') || '[]'));
                this.currentPlayer = 1; // 1=é»‘å…ˆ, 2=ç™½
                
                this.puzzles = [
                    {
                        name: "åŸºç¡€æ­»æ´»",
                        description: "é»‘å…ˆï¼Œäº‰å–åšæ´»",
                        type: "life",
                        goal: "åšæ´»é»‘æ£‹",
                        difficulty: 2,
                        board: [
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,2,2,2,0,0,0,0,0],
                            [0,0,2,1,1,1,2,0,0,0,0],
                            [0,0,2,1,0,1,2,0,0,0,0],
                            [0,0,2,1,1,1,2,0,0,0,0],
                            [0,0,0,2,2,2,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0]
                        ],
                        solution: [{row: 5, col: 4}],
                        firstMove: 1
                    },
                    {
                        name: "è§’éƒ¨æ­»æ´»",
                        description: "é»‘å…ˆï¼Œæ€æ­»ç™½æ£‹",
                        type: "death",
                        goal: "æ€æ­»ç™½æ£‹",
                        difficulty: 3,
                        board: [
                            [1,1,2,0,0,0,0,0,0,0,0],
                            [0,1,2,0,0,0,0,0,0,0,0],
                            [1,1,2,0,0,0,0,0,0,0,0],
                            [2,2,2,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0]
                        ],
                        solution: [{row: 1, col: 0}],
                        firstMove: 1
                    },
                    {
                        name: "æ‰‹ç­‹ç»ƒä¹ ",
                        description: "é»‘å…ˆï¼Œæ‰¾å‡ºå¦™æ‰‹",
                        type: "tesuji",
                        goal: "æ‰¾å‡ºæœ€ä½³æ‰‹ç­‹",
                        difficulty: 4,
                        board: [
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,1,2,2,1,0,0,0,0,0],
                            [0,1,1,2,0,2,1,1,0,0,0],
                            [0,1,2,2,2,2,2,1,0,0,0],
                            [0,1,2,1,1,1,2,1,0,0,0],
                            [0,1,2,1,0,1,2,1,0,0,0],
                            [0,1,2,1,1,1,2,1,0,0,0],
                            [0,1,2,2,2,2,2,1,0,0,0],
                            [0,1,1,1,1,1,1,1,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0]
                        ],
                        solution: [{row: 5, col: 4}],
                        firstMove: 1
                    }
                ];
                
                // ç”Ÿæˆæ›´å¤šé¢˜ç›®
                for (let i = 4; i <= 15; i++) {
                    this.puzzles.push({
                        name: `æ­»æ´»é¢˜${i}`,
                        description: `ç¬¬${i}é¢˜ï¼šå›´æ£‹åŸºç¡€è®­ç»ƒ`,
                        type: ["life", "death", "tesuji"][i % 3],
                        goal: "å®Œæˆç›®æ ‡",
                        difficulty: Math.floor(i / 3) + 1,
                        board: this.generateRandomPuzzle(),
                        solution: [],
                        firstMove: 1
                    });
                }
                
                this.init();
            }

            init() {
                this.createBoard();
                this.loadPuzzle(0);
                this.updateDisplay();
                this.updatePuzzleList();
                this.startTimer();
            }

            createBoard() {
                const board = document.getElementById('goBoard');
                // æ¸…é™¤ç°æœ‰å†…å®¹ä½†ä¿ç•™åæ ‡æ ‡ç­¾
                const cells = board.querySelectorAll('.go-cell');
                cells.forEach(cell => cell.remove());
                
                for (let row = 0; row < 11; row++) {
                    for (let col = 0; col < 11; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'go-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.onclick = () => this.handleCellClick(row, col);
                        
                        // æ·»åŠ æ£‹ç›˜çº¿æ¡æ ·å¼
                        if (row === 0) cell.style.borderTop = 'none';
                        if (row === 10) cell.style.borderBottom = 'none';
                        if (col === 0) cell.style.borderLeft = 'none';
                        if (col === 10) cell.style.borderRight = 'none';
                        
                        // æ˜Ÿä½æ ‡è®°
                        if ((row === 3 && col === 3) || (row === 3 && col === 7) || 
                            (row === 7 && col === 3) || (row === 7 && col === 7) || 
                            (row === 5 && col === 5)) {
                            cell.style.background = 'radial-gradient(circle, #8B4513 1px, transparent 1px)';
                        }
                        
                        board.appendChild(cell);
                    }
                }
            }

            loadPuzzle(index) {
                if (index < 0 || index >= this.puzzles.length) return;
                
                this.currentPuzzleIndex = index;
                const puzzle = this.puzzles[index];
                
                // å¤åˆ¶æ£‹ç›˜çŠ¶æ€
                this.board = puzzle.board.map(row => [...row]);
                this.moveHistory = [];
                this.currentPlayer = puzzle.firstMove || 1;
                this.startTime = Date.now();
                
                // æ›´æ–°UI
                document.getElementById('puzzleTitle').textContent = puzzle.name;
                document.getElementById('puzzleDescription').textContent = puzzle.description;
                document.getElementById('puzzleGoal').textContent = puzzle.goal;
                document.getElementById('puzzleDifficulty').textContent = 'â˜…'.repeat(puzzle.difficulty) + 'â˜†'.repeat(5 - puzzle.difficulty);
                
                const typeElement = document.getElementById('puzzleType');
                const typeNames = { life: 'åšæ´»é¢˜', death: 'æ€æ£‹é¢˜', tesuji: 'æ‰‹ç­‹é¢˜' };
                typeElement.textContent = typeNames[puzzle.type] || 'ç»¼åˆé¢˜';
                typeElement.className = `puzzle-type type-${puzzle.type}`;
                
                this.renderBoard();
                this.updateDisplay();
                this.updateMoveSequence();
            }

            renderBoard() {
                const cells = document.querySelectorAll('.go-cell');
                
                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const stone = this.board[row][col];
                    
                    // æ¸…é™¤ç°æœ‰æ£‹å­å’Œæ ‡è®°
                    cell.innerHTML = '';
                    cell.classList.remove('last-move');
                    
                    if (stone !== 0) {
                        const stoneElement = document.createElement('div');
                        stoneElement.className = `go-stone ${stone === 1 ? 'black' : 'white'}`;
                        
                        // æ˜¾ç¤ºæ‰‹æ•°
                        const moveIndex = this.moveHistory.findIndex(move => move.row === row && move.col === col);
                        if (moveIndex >= 0) {
                            stoneElement.textContent = moveIndex + 1;
                        }
                        
                        cell.appendChild(stoneElement);
                    }
                    
                    // æ ‡è®°æœ€åä¸€æ‰‹
                    if (this.moveHistory.length > 0) {
                        const lastMove = this.moveHistory[this.moveHistory.length - 1];
                        if (lastMove.row === row && lastMove.col === col) {
                            cell.classList.add('last-move');
                        }
                    }
                });
            }

            handleCellClick(row, col) {
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥è½å­
                if (this.board[row][col] !== 0) return;
                
                // è½å­
                this.makeMove(row, col);
            }

            makeMove(row, col) {
                // è®°å½•ç§»åŠ¨
                const move = {
                    row: row,
                    col: col,
                    player: this.currentPlayer,
                    captured: []
                };
                
                // è½å­
                this.board[row][col] = this.currentPlayer;
                
                // æ£€æŸ¥æå­
                const captured = this.checkCaptures(row, col);
                move.captured = captured;
                
                // ç§»é™¤è¢«æçš„å­
                captured.forEach(pos => {
                    this.board[pos.row][pos.col] = 0;
                });
                
                this.moveHistory.push(move);
                
                // åˆ‡æ¢ç©å®¶
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                
                this.renderBoard();
                this.updateDisplay();
                this.updateMoveSequence();
                
                // æ£€æŸ¥æ˜¯å¦è§£å†³é—®é¢˜
                this.checkPuzzleSolved();
            }

            checkCaptures(row, col) {
                const player = this.board[row][col];
                const opponent = player === 1 ? 2 : 1;
                const captured = [];
                
                // æ£€æŸ¥å››ä¸ªæ–¹å‘çš„æ•Œå­
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                
                directions.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (this.isValidPosition(newRow, newCol) && this.board[newRow][newCol] === opponent) {
                        const group = this.getGroup(newRow, newCol);
                        if (this.countLiberties(group) === 0) {
                            captured.push(...group);
                        }
                    }
                });
                
                return captured;
            }

            getGroup(row, col) {
                const player = this.board[row][col];
                const group = [];
                const visited = new Set();
                const stack = [{row, col}];
                
                while (stack.length > 0) {
                    const {row: r, col: c} = stack.pop();
                    const key = `${r},${c}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    if (this.board[r][c] === player) {
                        group.push({row: r, col: c});
                        
                        // æ£€æŸ¥å››ä¸ªæ–¹å‘
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        directions.forEach(([dr, dc]) => {
                            const newRow = r + dr;
                            const newCol = c + dc;
                            if (this.isValidPosition(newRow, newCol)) {
                                stack.push({row: newRow, col: newCol});
                            }
                        });
                    }
                }
                
                return group;
            }

            countLiberties(group) {
                const liberties = new Set();
                
                group.forEach(({row, col}) => {
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    directions.forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (this.isValidPosition(newRow, newCol) && this.board[newRow][newCol] === 0) {
                            liberties.add(`${newRow},${newCol}`);
                        }
                    });
                });
                
                return liberties.size;
            }

            isValidPosition(row, col) {
                return row >= 0 && row < 11 && col >= 0 && col < 11;
            }

            checkPuzzleSolved() {
                const puzzle = this.puzzles[this.currentPuzzleIndex];
                
                // ç®€åŒ–çš„è§£å†³æ£€æŸ¥
                if (puzzle.solution && puzzle.solution.length > 0) {
                    const solution = puzzle.solution[0];
                    const lastMove = this.moveHistory[this.moveHistory.length - 1];
                    
                    if (lastMove && lastMove.row === solution.row && lastMove.col === solution.col) {
                        this.solvePuzzle();
                    }
                } else {
                    // å¯¹äºæ²¡æœ‰é¢„è®¾è§£ç­”çš„é¢˜ç›®ï¼Œæ£€æŸ¥ç‰¹å®šæ¡ä»¶
                    if (this.moveHistory.length >= 3) {
                        // ç®€å•åˆ¤æ–­ï¼šå¦‚æœä¸‹äº†3æ‰‹ä»¥ä¸Šï¼Œå°±ç®—è§£å†³
                        this.solvePuzzle();
                    }
                }
            }

            solvePuzzle() {
                this.solvedPuzzles.add(this.currentPuzzleIndex);
                localStorage.setItem('solvedGoPuzzles', JSON.stringify([...this.solvedPuzzles]));
                
                const solveTime = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(solveTime / 60);
                const seconds = solveTime % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                document.getElementById('finalTime').textContent = timeString;
                document.getElementById('finalMoves').textContent = this.moveHistory.length;
                document.getElementById('successText').textContent = `ä½ æˆåŠŸè§£å†³äº†"${this.puzzles[this.currentPuzzleIndex].name}"ï¼`;
                document.getElementById('successModal').style.display = 'flex';
                
                this.updateDisplay();
                this.updatePuzzleList();
            }

            undoMove() {
                if (this.moveHistory.length === 0) return;
                
                const lastMove = this.moveHistory.pop();
                
                // æ¢å¤æ£‹ç›˜çŠ¶æ€
                this.board[lastMove.row][lastMove.col] = 0;
                
                // æ¢å¤è¢«æçš„å­
                lastMove.captured.forEach(pos => {
                    const opponent = lastMove.player === 1 ? 2 : 1;
                    this.board[pos.row][pos.col] = opponent;
                });
                
                // åˆ‡æ¢ç©å®¶
                this.currentPlayer = lastMove.player;
                
                this.renderBoard();
                this.updateDisplay();
                this.updateMoveSequence();
            }

            resetPuzzle() {
                this.loadPuzzle(this.currentPuzzleIndex);
            }

            nextPuzzle() {
                if (this.currentPuzzleIndex < this.puzzles.length - 1) {
                    this.loadPuzzle(this.currentPuzzleIndex + 1);
                }
            }

            previousPuzzle() {
                if (this.currentPuzzleIndex > 0) {
                    this.loadPuzzle(this.currentPuzzleIndex - 1);
                }
            }

            randomPuzzle() {
                const randomIndex = Math.floor(Math.random() * this.puzzles.length);
                this.loadPuzzle(randomIndex);
            }

            showHint() {
                const puzzle = this.puzzles[this.currentPuzzleIndex];
                if (puzzle.solution && puzzle.solution.length > 0) {
                    const hint = puzzle.solution[0];
                    const coord = this.positionToCoordinate(hint.row, hint.col);
                    alert(`æç¤ºï¼šè€ƒè™‘åœ¨ ${coord} ä½ç½®è½å­`);
                } else {
                    alert('è¿™é“é¢˜ç›®æš‚æ— æç¤ºï¼Œè¯·ä»”ç»†åˆ†ææ£‹å½¢ï¼');
                }
            }

            checkSolution() {
                // ç®€åŒ–çš„ç­”æ¡ˆæ£€æŸ¥
                if (this.moveHistory.length === 0) {
                    alert('è¯·å…ˆä¸‹æ£‹ï¼');
                    return;
                }
                
                const puzzle = this.puzzles[this.currentPuzzleIndex];
                if (puzzle.solution && puzzle.solution.length > 0) {
                    const solution = puzzle.solution[0];
                    const hasCorrectMove = this.moveHistory.some(move => 
                        move.row === solution.row && move.col === solution.col
                    );
                    
                    if (hasCorrectMove) {
                        alert('æ­å–œï¼ä½ æ‰¾åˆ°äº†æ­£ç¡®ç­”æ¡ˆï¼');
                        this.solvePuzzle();
                    } else {
                        alert('è¿˜æ²¡æ‰¾åˆ°æœ€ä½³è§£ç­”ï¼Œç»§ç»­æ€è€ƒï¼');
                    }
                } else {
                    alert('è¿™é“é¢˜ç›®çš„ç­”æ¡ˆæœ‰å¤šç§å¯èƒ½ï¼Œç»§ç»­æ¢ç´¢ï¼');
                }
            }

            analyzePosition() {
                // ç®€åŒ–çš„å½¢åŠ¿åˆ†æ
                let blackTerritory = 0;
                let whiteTerritory = 0;
                let blackStones = 0;
                let whiteStones = 0;
                
                for (let row = 0; row < 11; row++) {
                    for (let col = 0; col < 11; col++) {
                        if (this.board[row][col] === 1) {
                            blackStones++;
                        } else if (this.board[row][col] === 2) {
                            whiteStones++;
                        }
                    }
                }
                
                alert(`æ£‹å±€åˆ†æï¼š
                
é»‘æ£‹ï¼š${blackStones} å­
ç™½æ£‹ï¼š${whiteStones} å­
æ‰‹æ•°ï¼š${this.moveHistory.length}

å½“å‰è½®åˆ°ï¼š${this.currentPlayer === 1 ? 'é»‘æ£‹' : 'ç™½æ£‹'}
                
æç¤ºï¼šåˆ†æå„å—æ£‹çš„æ­»æ´»çŠ¶æ€ï¼Œå¯»æ‰¾å…³é”®ç‚¹ã€‚`);
            }

            generateRandomPuzzle() {
                // ç”Ÿæˆéšæœºé¢˜ç›®å¸ƒå±€
                const board = Array(11).fill(null).map(() => Array(11).fill(0));
                
                // éšæœºæ”¾ç½®ä¸€äº›æ£‹å­å½¢æˆæ­»æ´»é—®é¢˜
                const patterns = [
                    // åŸºç¡€æ­»æ´»æ¨¡å¼
                    [[1,1,1], [1,0,1], [1,1,1]],
                    // è§’éƒ¨æ­»æ´»
                    [[2,2,0], [1,2,0], [1,1,0]],
                    // è¾¹éƒ¨æ­»æ´»
                    [[0,2,2,2,0], [1,1,1,1,1], [0,1,0,1,0]]
                ];
                
                const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                const startRow = Math.floor(Math.random() * (11 - pattern.length));
                const startCol = Math.floor(Math.random() * (11 - pattern[0].length));
                
                for (let i = 0; i < pattern.length; i++) {
                    for (let j = 0; j < pattern[i].length; j++) {
                        if (pattern[i][j] !== 0) {
                            board[startRow + i][startCol + j] = pattern[i][j];
                        }
                    }
                }
                
                return board;
            }

            positionToCoordinate(row, col) {
                const letters = 'ABCDEFGHJKLMNOPQRS';
                return `${letters[col]}${11 - row}`;
            }

            updateDisplay() {
                document.getElementById('currentPuzzle').textContent = this.currentPuzzleIndex + 1;
                document.getElementById('moveCount').textContent = this.moveHistory.length;
                document.getElementById('solvedCount').textContent = `${this.solvedPuzzles.size}/${this.puzzles.length}`;
                document.getElementById('undoBtn').disabled = this.moveHistory.length === 0;
            }

            updateMoveSequence() {
                const container = document.getElementById('moveSequence');
                container.innerHTML = '';
                
                this.moveHistory.forEach((move, index) => {
                    const entry = document.createElement('div');
                    entry.className = `move-entry ${move.player === 1 ? 'black' : 'white'}`;
                    const coord = this.positionToCoordinate(move.row, move.col);
                    const player = move.player === 1 ? 'â—' : 'â—‹';
                    entry.textContent = `${index + 1}. ${player} ${coord}`;
                    container.appendChild(entry);
                });
                
                container.scrollTop = container.scrollHeight;
            }

            updatePuzzleList() {
                const container = document.getElementById('puzzleList');
                container.innerHTML = '';
                
                this.puzzles.forEach((puzzle, index) => {
                    const item = document.createElement('div');
                    let className = 'puzzle-item';
                    if (index === this.currentPuzzleIndex) className += ' current';
                    if (this.solvedPuzzles.has(index)) className += ' solved';
                    
                    item.className = className;
                    item.onclick = () => this.loadPuzzle(index);
                    
                    const solved = this.solvedPuzzles.has(index) ? ' âœ“' : '';
                    const typeNames = { life: 'æ´»', death: 'æ€', tesuji: 'ç­‹' };
                    
                    item.innerHTML = `
                        <div style="font-weight: bold;">${index + 1}. ${puzzle.name}${solved}</div>
                        <div style="font-size: 0.8rem; color: #666;">${typeNames[puzzle.type]} â˜…${puzzle.difficulty}</div>
                    `;
                    
                    container.appendChild(item);
                });
            }

            startTimer() {
                setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('solveTime').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
            }

            closeSuccessModal() {
                document.getElementById('successModal').style.display = 'none';
                this.nextPuzzle();
            }

            showRules() {
                alert(`å›´æ£‹æ­»æ´»é¢˜æ¸¸æˆè§„åˆ™ï¼š

ç›®æ ‡ï¼š
â€¢ æ ¹æ®é¢˜ç›®è¦æ±‚å®Œæˆåšæ´»ã€æ€æ£‹æˆ–æ‰‹ç­‹ä»»åŠ¡
â€¢ é€šå¸¸é»‘å…ˆï¼Œæ‰¾åˆ°æœ€ä½³ç€ç‚¹

åŸºæœ¬è§„åˆ™ï¼š
â€¢ ç‚¹å‡»æ£‹ç›˜ç©ºç‚¹è½å­
â€¢ éµå¾ªå›´æ£‹åŸºæœ¬è§„åˆ™ï¼ˆæ°”ã€æå­ç­‰ï¼‰
â€¢ å¯ä»¥æ‚”æ£‹å’Œé‡ç½®

é¢˜ç›®ç±»å‹ï¼š
â€¢ åšæ´»é¢˜ï¼šè®©å·±æ–¹æ£‹å­è·å¾—ä¸¤çœ¼åšæ´»
â€¢ æ€æ£‹é¢˜ï¼šæ€æ­»å¯¹æ–¹æ£‹å­
â€¢ æ‰‹ç­‹é¢˜ï¼šæ‰¾å‡ºç²¾å¦™çš„æŠ€å·§ç€æ³•

æ“ä½œè¯´æ˜ï¼š
â€¢ å·¦é”®ç‚¹å‡»ç©ºç‚¹è½å­
â€¢ ä½¿ç”¨æ‚”æ£‹å¯ä»¥æ’¤é”€ä¸Šä¸€æ­¥
â€¢ æ£€æŸ¥ç­”æ¡ˆéªŒè¯è§£æ³•æ­£ç¡®æ€§
â€¢ æç¤ºåŠŸèƒ½å¸®åŠ©æ€è€ƒ

å›´æ£‹çŸ¥è¯†ï¼š
â€¢ æ°”ï¼šæ£‹å­ç›´æ¥ç›¸é‚»çš„ç©ºç‚¹
â€¢ çœ¼ï¼šè¢«å·±æ–¹æ£‹å­å›´ä½çš„ç©ºç‚¹
â€¢ æ­»æ´»ï¼šæ£‹å­èƒ½å¦åšæˆä¸¤çœ¼å­˜æ´»

è§£é¢˜æŠ€å·§ï¼š
â€¢ ä»”ç»†åˆ†æåŒæ–¹æ£‹å­çš„æ°”æ•°
â€¢ å¯»æ‰¾å…³é”®çš„åšçœ¼ç‚¹æˆ–ç ´çœ¼ç‚¹
â€¢ è€ƒè™‘å…ˆæ‰‹å’Œåæ‰‹çš„å·®åˆ«
â€¢ æ³¨æ„å¯¹æ€ä¸­çš„ç¼“æ‰‹å’Œæ€¥æ‰‹`);
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        const goPuzzle = new GoPuzzleGame();
    </script>
</body>
</html>