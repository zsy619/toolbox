<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰å›½æ€ - ç»å…¸èº«ä»½æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #8B4513 0%, #CD853F 50%, #D2691E 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #8B4513;
            margin-bottom: 20px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-card {
            background: #FFF8DC;
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #D2691E;
        }

        .info-label {
            color: #8B4513;
            font-size: 0.9rem;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .info-value {
            color: #4A4A4A;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            background: #8B4513;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        button:hover {
            background: #A0522D;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .game-board {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            margin: 20px 0;
            min-height: 600px;
        }

        .players-section {
            background: #FFF8DC;
            border-radius: 15px;
            padding: 15px;
            border: 2px solid #D2691E;
        }

        .section-title {
            text-align: center;
            color: #8B4513;
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .player-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border: 2px solid #DDD;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .player-card:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .player-card.current {
            border-color: #FF6B35;
            background: #FFF5F0;
        }

        .player-card.dead {
            opacity: 0.5;
            background: #F5F5F5;
        }

        .player-name {
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 5px;
        }

        .player-role {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }

        .player-role.lord { color: #FFD700; }
        .player-role.loyal { color: #32CD32; }
        .player-role.rebel { color: #DC143C; }
        .player-role.spy { color: #8A2BE2; }

        .player-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #666;
        }

        .hp-bar {
            background: #DDD;
            height: 8px;
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }

        .hp-fill {
            background: #32CD32;
            height: 100%;
            transition: width 0.3s ease;
        }

        .hp-fill.low { background: #FF4500; }
        .hp-fill.critical { background: #DC143C; }

        .center-area {
            background: #FFF8DC;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #D2691E;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-phase {
            background: #8B4513;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .card-area {
            flex: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .deck-area {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }

        .deck {
            width: 100px;
            height: 140px;
            background: #8B4513;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid #A0522D;
        }

        .deck:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .deck.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .cards-display {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .card {
            width: 80px;
            height: 110px;
            background: white;
            border: 2px solid #8B4513;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            text-align: center;
            position: relative;
        }

        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card.selected {
            border-color: #FF6B35;
            background: #FFF5F0;
            transform: translateY(-5px);
        }

        .card-name {
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 5px;
        }

        .card-type {
            font-size: 0.7rem;
            color: #666;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-btn {
            background: #FF6B35;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .action-btn:hover {
            background: #E55A2B;
            transform: translateY(-1px);
        }

        .action-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .game-log {
            background: #FFF8DC;
            border-radius: 15px;
            padding: 15px;
            border: 2px solid #D2691E;
            max-height: 400px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #E0E0E0;
            font-size: 0.9rem;
            color: #4A4A4A;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.important {
            color: #DC143C;
            font-weight: bold;
        }

        .winner-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .winner-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            animation: winnerPop 0.5s ease-out;
            border: 3px solid #8B4513;
        }

        @keyframes winnerPop {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .character-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .character-card {
            background: white;
            border: 2px solid #8B4513;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .character-card:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .character-card.selected {
            border-color: #FF6B35;
            background: #FFF5F0;
        }

        .character-name {
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 5px;
        }

        .character-skill {
            font-size: 0.8rem;
            color: #666;
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .game-board {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .controls {
                gap: 8px;
            }
            
            button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
            
            .character-selection {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>âš”ï¸ ä¸‰å›½æ€ âš”ï¸</h1>
        
        <div class="game-info">
            <div class="info-card">
                <div class="info-label">å½“å‰ç©å®¶</div>
                <div class="info-value" id="currentPlayer">ç­‰å¾…å¼€å§‹</div>
            </div>
            <div class="info-card">
                <div class="info-label">æ¸¸æˆé˜¶æ®µ</div>
                <div class="info-value" id="gamePhase">å‡†å¤‡é˜¶æ®µ</div>
            </div>
            <div class="info-card">
                <div class="info-label">å›åˆæ•°</div>
                <div class="info-value" id="roundCount">0</div>
            </div>
            <div class="info-card">
                <div class="info-label">å‰©ä½™ç©å®¶</div>
                <div class="info-value" id="aliveCount">0</div>
            </div>
        </div>

        <div class="controls">
            <button id="newGameBtn" onclick="threeKingdoms.newGame()">æ–°æ¸¸æˆ</button>
            <button id="endTurnBtn" onclick="threeKingdoms.endTurn()" disabled>ç»“æŸå›åˆ</button>
            <button id="rulesBtn" onclick="threeKingdoms.showRules()">æ¸¸æˆè§„åˆ™</button>
            <button id="statsBtn" onclick="threeKingdoms.showStats()">æ¸¸æˆç»Ÿè®¡</button>
        </div>

        <div class="game-board">
            <div class="players-section">
                <div class="section-title">ç©å®¶çŠ¶æ€</div>
                <div id="playersContainer"></div>
            </div>

            <div class="center-area">
                <div class="game-phase" id="phaseDisplay">å‡†å¤‡é˜¶æ®µ</div>
                
                <div class="deck-area">
                    <div class="deck" id="drawDeck" onclick="threeKingdoms.drawCard()">
                        <div>æ‘¸ç‰Œå †<br>(<span id="deckCount">24</span>)</div>
                    </div>
                    <div class="deck" id="discardDeck">
                        <div>å¼ƒç‰Œå †<br>(<span id="discardCount">0</span>)</div>
                    </div>
                </div>

                <div class="cards-display" id="handCards"></div>

                <div class="action-buttons">
                    <button class="action-btn" id="attackBtn" onclick="threeKingdoms.useCard('attack')" disabled>æ€</button>
                    <button class="action-btn" id="dodgeBtn" onclick="threeKingdoms.useCard('dodge')" disabled>é—ª</button>
                    <button class="action-btn" id="peachBtn" onclick="threeKingdoms.useCard('peach')" disabled>æ¡ƒ</button>
                    <button class="action-btn" id="equipBtn" onclick="threeKingdoms.useCard('equip')" disabled>è£…å¤‡</button>
                </div>
            </div>

            <div class="game-log">
                <div class="section-title">æ¸¸æˆæ—¥å¿—</div>
                <div id="gameLog"></div>
            </div>
        </div>

        <div id="characterSelection" style="display: none;">
            <h3 style="text-align: center; margin-bottom: 20px;">é€‰æ‹©æ­¦å°†</h3>
            <div class="character-selection" id="charactersGrid"></div>
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="threeKingdoms.confirmCharacter()">ç¡®è®¤é€‰æ‹©</button>
                <button onclick="threeKingdoms.randomCharacter()">éšæœºé€‰æ‹©</button>
            </div>
        </div>
    </div>

    <div class="winner-modal" id="winnerModal">
        <div class="winner-content">
            <h2 id="winnerTitle">ğŸ‰ æ¸¸æˆç»“æŸ ğŸ‰</h2>
            <p id="winnerText"></p>
            <button onclick="threeKingdoms.closeWinnerModal()">å†æ¥ä¸€å±€</button>
        </div>
    </div>

    <script>
        class ThreeKingdomsGame {
            constructor() {
                this.players = [];
                this.currentPlayerIndex = 0;
                this.gamePhase = 'prepare';
                this.roundCount = 0;
                this.gameStarted = false;
                this.deckCards = 24;
                this.discardCards = 0;
                this.selectedCard = null;
                this.gameLog = [];
                
                this.characters = [
                    { name: 'åˆ˜å¤‡', skill: 'ä»å¾·', hp: 4, description: 'å¯ä»¥å°†æ‰‹ç‰Œç»™äºˆå…¶ä»–è§’è‰²' },
                    { name: 'å…³ç¾½', skill: 'æ­¦åœ£', hp: 4, description: 'çº¢è‰²æ‰‹ç‰Œå¯ä»¥å½“ä½œæ€ä½¿ç”¨' },
                    { name: 'å¼ é£', skill: 'å’†å“®', hp: 4, description: 'å‡ºç‰Œé˜¶æ®µå¯ä»¥ä½¿ç”¨ä»»æ„æ•°é‡çš„æ€' },
                    { name: 'èµµäº‘', skill: 'é¾™èƒ†', hp: 4, description: 'å¯ä»¥å°†æ€å½“ä½œé—ªä½¿ç”¨ï¼Œé—ªå½“ä½œæ€ä½¿ç”¨' },
                    { name: 'é©¬è¶…', skill: 'é©¬æœ¯', hp: 4, description: 'è®¡ç®—ä¸å…¶ä»–è§’è‰²çš„è·ç¦»-1' },
                    { name: 'é»„å¿ ', skill: 'çƒˆå¼“', hp: 4, description: 'å¯ä»¥å¯¹è·ç¦»2ä»¥å†…çš„è§’è‰²ä½¿ç”¨æ€' },
                    { name: 'æ›¹æ“', skill: 'å¥¸é›„', hp: 4, description: 'å—åˆ°ä¼¤å®³åå¯ä»¥è·å¾—å¯¹åº”çš„ç‰Œ' },
                    { name: 'éƒ­å˜‰', skill: 'å¤©å¦’', hp: 3, description: 'æ¯å½“å¤±å»ä¸€ç‚¹ä½“åŠ›ï¼Œå¯ä»¥æ‘¸ä¸¤å¼ ç‰Œ' },
                    { name: 'å¸é©¬æ‡¿', skill: 'åé¦ˆ', hp: 3, description: 'å—åˆ°ä¼¤å®³åå¯ä»¥è·å¾—ä¼¤å®³æ¥æºçš„ä¸€å¼ æ‰‹ç‰Œ' },
                    { name: 'å¤ä¾¯æƒ‡', skill: 'åˆšçƒˆ', hp: 4, description: 'å—åˆ°ä¼¤å®³åå¯ä»¥è¿›è¡Œåˆ¤å®šé€ æˆä¼¤å®³' }
                ];
                
                this.cardTypes = ['attack', 'dodge', 'peach', 'equip'];
                this.roles = ['lord', 'loyal', 'rebel', 'spy'];
                this.roleNames = { 'lord': 'ä¸»å…¬', 'loyal': 'å¿ è‡£', 'rebel': 'åè´¼', 'spy': 'å†…å¥¸' };
                
                this.gameStats = JSON.parse(localStorage.getItem('threeKingdomsStats') || '{}');
                
                this.init();
            }

            init() {
                this.updateDisplay();
                this.addLogEntry('æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼Œç‚¹å‡»æ–°æ¸¸æˆå¼€å§‹');
            }

            newGame() {
                this.gameStarted = false;
                this.currentPlayerIndex = 0;
                this.gamePhase = 'prepare';
                this.roundCount = 0;
                this.deckCards = 24;
                this.discardCards = 0;
                this.selectedCard = null;
                this.gameLog = [];
                
                // åˆ›å»ºç©å®¶
                this.createPlayers();
                this.assignRoles();
                this.updateDisplay();
                this.addLogEntry('æ–°æ¸¸æˆå¼€å§‹ï¼å„ç©å®¶å¼€å§‹é€‰æ‹©æ­¦å°†');
                
                document.getElementById('winnerModal').style.display = 'none';
                this.showCharacterSelection();
            }

            createPlayers() {
                this.players = [];
                const playerNames = ['ç©å®¶1', 'ç©å®¶2', 'ç©å®¶3', 'ç©å®¶4', 'ç©å®¶5'];
                
                for (let i = 0; i < 5; i++) {
                    this.players.push({
                        id: i,
                        name: playerNames[i],
                        character: null,
                        role: null,
                        hp: 4,
                        maxHp: 4,
                        handCards: [],
                        equipment: [],
                        alive: true,
                        isAI: i > 0 // é™¤äº†ç©å®¶1ï¼Œå…¶ä»–éƒ½æ˜¯AI
                    });
                }
            }

            assignRoles() {
                const roles = ['lord', 'loyal', 'loyal', 'rebel', 'spy'];
                const shuffledRoles = this.shuffleArray([...roles]);
                
                this.players.forEach((player, index) => {
                    player.role = shuffledRoles[index];
                    if (player.role === 'lord') {
                        player.maxHp = 5;
                        player.hp = 5;
                    }
                });
            }

            showCharacterSelection() {
                const selectionDiv = document.getElementById('characterSelection');
                const charactersGrid = document.getElementById('charactersGrid');
                
                charactersGrid.innerHTML = '';
                
                // éšæœºé€‰æ‹©å¯ç”¨æ­¦å°†
                const availableCharacters = this.shuffleArray([...this.characters]).slice(0, 8);
                
                availableCharacters.forEach(character => {
                    const characterCard = document.createElement('div');
                    characterCard.className = 'character-card';
                    characterCard.onclick = () => this.selectCharacter(character);
                    characterCard.innerHTML = `
                        <div class="character-name">${character.name}</div>
                        <div class="character-skill">${character.skill}</div>
                        <div class="character-skill" style="font-size: 0.7rem;">${character.description}</div>
                    `;
                    charactersGrid.appendChild(characterCard);
                });
                
                selectionDiv.style.display = 'block';
            }

            selectCharacter(character) {
                document.querySelectorAll('.character-card.selected').forEach(card => {
                    card.classList.remove('selected');
                });
                
                event.target.closest('.character-card').classList.add('selected');
                this.selectedCharacter = character;
            }

            confirmCharacter() {
                if (!this.selectedCharacter) {
                    alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ­¦å°†ï¼');
                    return;
                }
                
                this.players[0].character = this.selectedCharacter;
                this.players[0].hp = this.selectedCharacter.hp;
                this.players[0].maxHp = this.selectedCharacter.hp;
                
                // AIè‡ªåŠ¨é€‰æ‹©æ­¦å°†
                for (let i = 1; i < this.players.length; i++) {
                    const availableCharacters = this.characters.filter(char => 
                        !this.players.some(p => p.character && p.character.name === char.name)
                    );
                    
                    if (availableCharacters.length > 0) {
                        const randomCharacter = availableCharacters[Math.floor(Math.random() * availableCharacters.length)];
                        this.players[i].character = randomCharacter;
                        this.players[i].hp = randomCharacter.hp;
                        this.players[i].maxHp = randomCharacter.hp;
                    }
                }
                
                document.getElementById('characterSelection').style.display = 'none';
                this.startGame();
            }

            randomCharacter() {
                const availableCharacters = this.characters;
                const randomCharacter = availableCharacters[Math.floor(Math.random() * availableCharacters.length)];
                
                document.querySelectorAll('.character-card.selected').forEach(card => {
                    card.classList.remove('selected');
                });
                
                // æ‰¾åˆ°å¯¹åº”çš„æ­¦å°†å¡ç‰‡å¹¶é€‰ä¸­
                const characterCards = document.querySelectorAll('.character-card');
                characterCards.forEach(card => {
                    if (card.querySelector('.character-name').textContent === randomCharacter.name) {
                        card.classList.add('selected');
                    }
                });
                
                this.selectedCharacter = randomCharacter;
            }

            startGame() {
                this.gameStarted = true;
                this.gamePhase = 'draw';
                this.currentPlayerIndex = this.players.findIndex(p => p.role === 'lord');
                
                // å‘åˆå§‹æ‰‹ç‰Œ
                this.players.forEach(player => {
                    for (let i = 0; i < 4; i++) {
                        this.dealCard(player);
                    }
                });
                
                this.addLogEntry(`æ¸¸æˆå¼€å§‹ï¼${this.players[this.currentPlayerIndex].name}(${this.players[this.currentPlayerIndex].character.name})çš„å›åˆ`);
                this.updateDisplay();
                this.nextPhase();
            }

            nextPhase() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                
                switch (this.gamePhase) {
                    case 'draw':
                        this.drawPhase();
                        break;
                    case 'play':
                        this.playPhase();
                        break;
                    case 'discard':
                        this.discardPhase();
                        break;
                    case 'end':
                        this.endPhase();
                        break;
                }
            }

            drawPhase() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                this.addLogEntry(`${currentPlayer.name} è¿›å…¥æ‘¸ç‰Œé˜¶æ®µ`);
                
                // æ‘¸ä¸¤å¼ ç‰Œ
                for (let i = 0; i < 2; i++) {
                    this.dealCard(currentPlayer);
                }
                
                this.gamePhase = 'play';
                this.updateDisplay();
                
                if (currentPlayer.isAI) {
                    setTimeout(() => this.aiPlayPhase(), 1000);
                }
            }

            playPhase() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                this.addLogEntry(`${currentPlayer.name} è¿›å…¥å‡ºç‰Œé˜¶æ®µ`);
                this.updateDisplay();
            }

            aiPlayPhase() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                
                // AIç®€å•ç­–ç•¥ï¼šéšæœºä½¿ç”¨ä¸€å¼ ç‰Œæˆ–è·³è¿‡
                if (currentPlayer.handCards.length > 0 && Math.random() > 0.3) {
                    const randomCard = currentPlayer.handCards[Math.floor(Math.random() * currentPlayer.handCards.length)];
                    this.aiUseCard(currentPlayer, randomCard);
                }
                
                setTimeout(() => this.endTurn(), 1500);
            }

            aiUseCard(player, card) {
                const targets = this.players.filter(p => p.alive && p.id !== player.id);
                if (targets.length === 0) return;
                
                const target = targets[Math.floor(Math.random() * targets.length)];
                
                switch (card.type) {
                    case 'attack':
                        if (target.hp > 0) {
                            this.addLogEntry(`${player.name} å¯¹ ${target.name} ä½¿ç”¨äº†æ€`);
                            this.dealDamage(target, 1);
                        }
                        break;
                    case 'peach':
                        if (player.hp < player.maxHp) {
                            this.addLogEntry(`${player.name} ä½¿ç”¨äº†æ¡ƒï¼Œå›å¤1ç‚¹ä½“åŠ›`);
                            player.hp = Math.min(player.hp + 1, player.maxHp);
                        }
                        break;
                }
                
                // ç§»é™¤ä½¿ç”¨çš„ç‰Œ
                const cardIndex = player.handCards.indexOf(card);
                if (cardIndex > -1) {
                    player.handCards.splice(cardIndex, 1);
                    this.discardCards++;
                }
            }

            discardPhase() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                const excessCards = currentPlayer.handCards.length - currentPlayer.hp;
                
                if (excessCards > 0) {
                    this.addLogEntry(`${currentPlayer.name} éœ€è¦å¼ƒç½® ${excessCards} å¼ ç‰Œ`);
                    
                    if (currentPlayer.isAI) {
                        // AIè‡ªåŠ¨å¼ƒç‰Œ
                        for (let i = 0; i < excessCards; i++) {
                            if (currentPlayer.handCards.length > 0) {
                                const discardedCard = currentPlayer.handCards.pop();
                                this.discardCards++;
                            }
                        }
                    } else {
                        // ç©å®¶æ‰‹åŠ¨å¼ƒç‰Œï¼ˆç®€åŒ–å¤„ç†ï¼‰
                        while (currentPlayer.handCards.length > currentPlayer.hp) {
                            currentPlayer.handCards.pop();
                            this.discardCards++;
                        }
                    }
                }
                
                this.gamePhase = 'end';
                this.nextPhase();
            }

            endPhase() {
                this.gamePhase = 'draw';
                this.nextPlayer();
                
                if (this.checkWinCondition()) {
                    return;
                }
                
                this.updateDisplay();
                setTimeout(() => this.nextPhase(), 500);
            }

            nextPlayer() {
                do {
                    this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;
                } while (!this.players[this.currentPlayerIndex].alive);
                
                if (this.currentPlayerIndex === 0) {
                    this.roundCount++;
                }
            }

            endTurn() {
                this.gamePhase = 'discard';
                this.nextPhase();
            }

            drawCard() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                if (!this.gameStarted || currentPlayer.isAI || this.gamePhase !== 'play') return;
                
                this.dealCard(currentPlayer);
                this.updateDisplay();
            }

            dealCard(player) {
                if (this.deckCards <= 0) {
                    this.reshuffleDeck();
                }
                
                const cardTypes = ['attack', 'dodge', 'peach', 'equip'];
                const randomType = cardTypes[Math.floor(Math.random() * cardTypes.length)];
                
                const card = {
                    id: Date.now() + Math.random(),
                    type: randomType,
                    name: this.getCardName(randomType),
                    suit: ['â™ ', 'â™¥', 'â™£', 'â™¦'][Math.floor(Math.random() * 4)],
                    value: Math.floor(Math.random() * 13) + 1
                };
                
                player.handCards.push(card);
                this.deckCards--;
            }

            getCardName(type) {
                const names = {
                    'attack': 'æ€',
                    'dodge': 'é—ª',
                    'peach': 'æ¡ƒ',
                    'equip': 'è£…å¤‡'
                };
                return names[type] || 'æœªçŸ¥';
            }

            reshuffleDeck() {
                this.deckCards = this.discardCards;
                this.discardCards = 0;
                this.addLogEntry('é‡æ–°æ´—ç‰Œ');
            }

            useCard(cardType) {
                const currentPlayer = this.players[this.currentPlayerIndex];
                if (!this.gameStarted || currentPlayer.isAI || this.gamePhase !== 'play') return;
                
                const card = currentPlayer.handCards.find(c => c.type === cardType);
                if (!card) {
                    this.addLogEntry('æ²¡æœ‰å¯ç”¨çš„ç‰Œ');
                    return;
                }
                
                this.executeCardEffect(currentPlayer, card);
                
                // ç§»é™¤ä½¿ç”¨çš„ç‰Œ
                const cardIndex = currentPlayer.handCards.indexOf(card);
                currentPlayer.handCards.splice(cardIndex, 1);
                this.discardCards++;
                
                this.updateDisplay();
            }

            executeCardEffect(player, card) {
                const enemies = this.players.filter(p => p.alive && p.id !== player.id && this.isEnemy(player, p));
                
                switch (card.type) {
                    case 'attack':
                        if (enemies.length > 0) {
                            const target = enemies[Math.floor(Math.random() * enemies.length)];
                            this.addLogEntry(`${player.name} å¯¹ ${target.name} ä½¿ç”¨äº†æ€`);
                            this.dealDamage(target, 1);
                        }
                        break;
                        
                    case 'peach':
                        if (player.hp < player.maxHp) {
                            player.hp++;
                            this.addLogEntry(`${player.name} ä½¿ç”¨äº†æ¡ƒï¼Œå›å¤1ç‚¹ä½“åŠ›`);
                        }
                        break;
                        
                    case 'equip':
                        player.equipment.push(card);
                        this.addLogEntry(`${player.name} è£…å¤‡äº† ${card.name}`);
                        break;
                }
            }

            isEnemy(player1, player2) {
                if (player1.role === 'lord') {
                    return player2.role === 'rebel' || player2.role === 'spy';
                } else if (player1.role === 'loyal') {
                    return player2.role === 'rebel' || player2.role === 'spy';
                } else if (player1.role === 'rebel') {
                    return player2.role === 'lord' || player2.role === 'loyal' || player2.role === 'spy';
                } else if (player1.role === 'spy') {
                    return true; // å†…å¥¸ä¸æ‰€æœ‰äººä¸ºæ•Œ
                }
                return false;
            }

            dealDamage(target, damage) {
                target.hp -= damage;
                
                if (target.hp <= 0) {
                    target.alive = false;
                    this.addLogEntry(`${target.name}(${target.character.name}) é˜µäº¡`, true);
                    
                    // å¥–åŠ±å’Œæƒ©ç½š
                    this.handleDeathReward(target);
                }
                
                this.updateDisplay();
            }

            handleDeathReward(deadPlayer) {
                const killer = this.players[this.currentPlayerIndex];
                
                if (deadPlayer.role === 'rebel') {
                    // æ€æ­»åè´¼å¥–åŠ±æ‘¸ç‰Œ
                    for (let i = 0; i < 3; i++) {
                        this.dealCard(killer);
                    }
                    this.addLogEntry(`${killer.name} å‡»æ€åè´¼ï¼Œå¥–åŠ±æ‘¸3å¼ ç‰Œ`);
                } else if (deadPlayer.role === 'loyal' && killer.role === 'lord') {
                    // ä¸»å…¬è¯¯æ€å¿ è‡£æƒ©ç½š
                    killer.handCards = [];
                    killer.equipment = [];
                    this.addLogEntry(`${killer.name} è¯¯æ€å¿ è‡£ï¼Œå¼ƒç½®æ‰€æœ‰ç‰Œ`);
                }
            }

            checkWinCondition() {
                const alivePlayers = this.players.filter(p => p.alive);
                const lordAlive = alivePlayers.some(p => p.role === 'lord');
                const rebelsAlive = alivePlayers.some(p => p.role === 'rebel');
                const spyAlive = alivePlayers.some(p => p.role === 'spy');
                
                if (!lordAlive) {
                    if (spyAlive && alivePlayers.length === 1) {
                        this.endGame('spy', 'å†…å¥¸è·èƒœï¼');
                        return true;
                    } else if (rebelsAlive) {
                        this.endGame('rebel', 'åè´¼è·èƒœï¼');
                        return true;
                    }
                } else if (!rebelsAlive && !spyAlive) {
                    this.endGame('loyal', 'ä¸»å…¬å’Œå¿ è‡£è·èƒœï¼');
                    return true;
                }
                
                return false;
            }

            endGame(winnerRole, message) {
                this.gameStarted = false;
                
                // æ›´æ–°ç»Ÿè®¡
                if (!this.gameStats[winnerRole]) {
                    this.gameStats[winnerRole] = 0;
                }
                this.gameStats[winnerRole]++;
                localStorage.setItem('threeKingdomsStats', JSON.stringify(this.gameStats));
                
                document.getElementById('winnerTitle').textContent = 'ğŸ‰ æ¸¸æˆç»“æŸ ğŸ‰';
                document.getElementById('winnerText').textContent = message;
                document.getElementById('winnerModal').style.display = 'flex';
                
                this.addLogEntry(message, true);
            }

            closeWinnerModal() {
                document.getElementById('winnerModal').style.display = 'none';
                this.newGame();
            }

            showRules() {
                alert(`ä¸‰å›½æ€æ¸¸æˆè§„åˆ™ï¼š
                
èº«ä»½ä»‹ç»ï¼š
â€¢ ä¸»å…¬ï¼šç»Ÿé¢†å…¨å±€ï¼Œéœ€è¦æ¶ˆç­æ‰€æœ‰åè´¼å’Œå†…å¥¸
â€¢ å¿ è‡£ï¼šè¾…ä½ä¸»å…¬ï¼Œä¸ä¸»å…¬å…±åŒè·èƒœ
â€¢ åè´¼ï¼šæ¨ç¿»ä¸»å…¬ï¼Œæ€æ­»ä¸»å…¬å³å¯è·èƒœ
â€¢ å†…å¥¸ï¼šæœ€åå­˜æ´»çš„ç©å®¶ï¼Œéœ€è¦åœ¨æœ€åå•æŒ‘ä¸»å…¬

æ¸¸æˆæµç¨‹ï¼š
1. æ‘¸ç‰Œé˜¶æ®µï¼šæ‘¸ä¸¤å¼ ç‰Œ
2. å‡ºç‰Œé˜¶æ®µï¼šå¯ä»¥ä½¿ç”¨æ‰‹ç‰Œ
3. å¼ƒç‰Œé˜¶æ®µï¼šæ‰‹ç‰Œæ•°ä¸èƒ½è¶…è¿‡å½“å‰ä½“åŠ›å€¼
4. ç»“æŸé˜¶æ®µï¼šå›åˆç»“æŸ

åŸºæœ¬ç‰Œï¼š
â€¢ æ€ï¼šæ”»å‡»å…¶ä»–è§’è‰²
â€¢ é—ªï¼šæŠµæŒ¡æ€çš„æ”»å‡»
â€¢ æ¡ƒï¼šå›å¤1ç‚¹ä½“åŠ›

è·èƒœæ¡ä»¶ï¼š
â€¢ ä¸»å…¬/å¿ è‡£ï¼šæ€æ­»æ‰€æœ‰åè´¼å’Œå†…å¥¸
â€¢ åè´¼ï¼šæ€æ­»ä¸»å…¬
â€¢ å†…å¥¸ï¼šæˆä¸ºæœ€åå­˜æ´»çš„è§’è‰²`);
            }

            showStats() {
                let statsText = 'æ¸¸æˆç»Ÿè®¡ï¼š\n\n';
                const roleNames = { 'lord': 'ä¸»å…¬/å¿ è‡£', 'rebel': 'åè´¼', 'spy': 'å†…å¥¸' };
                
                Object.entries(this.gameStats).forEach(([role, wins]) => {
                    statsText += `${roleNames[role] || role}ï¼š${wins}æ¬¡è·èƒœ\n`;
                });
                
                if (Object.keys(this.gameStats).length === 0) {
                    statsText += 'æš‚æ— ç»Ÿè®¡æ•°æ®';
                }
                
                alert(statsText);
            }

            selectCard(cardElement, card) {
                // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
                document.querySelectorAll('.card.selected').forEach(c => {
                    c.classList.remove('selected');
                });
                
                cardElement.classList.add('selected');
                this.selectedCard = card;
            }

            updateDisplay() {
                // æ›´æ–°å½“å‰ç©å®¶ä¿¡æ¯
                const currentPlayer = this.players[this.currentPlayerIndex];
                if (currentPlayer) {
                    document.getElementById('currentPlayer').textContent = 
                        `${currentPlayer.name}(${currentPlayer.character ? currentPlayer.character.name : 'æœªé€‰æ‹©'})`;
                }
                
                document.getElementById('gamePhase').textContent = this.getPhaseText();
                document.getElementById('phaseDisplay').textContent = this.getPhaseText();
                document.getElementById('roundCount').textContent = this.roundCount;
                document.getElementById('aliveCount').textContent = this.players.filter(p => p.alive).length;
                document.getElementById('deckCount').textContent = this.deckCards;
                document.getElementById('discardCount').textContent = this.discardCards;
                
                // æ›´æ–°ç©å®¶åˆ—è¡¨
                this.updatePlayersDisplay();
                
                // æ›´æ–°æ‰‹ç‰Œæ˜¾ç¤º
                this.updateHandCardsDisplay();
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                this.updateButtonStates();
            }

            updatePlayersDisplay() {
                const container = document.getElementById('playersContainer');
                container.innerHTML = '';
                
                this.players.forEach((player, index) => {
                    const playerCard = document.createElement('div');
                    playerCard.className = `player-card ${index === this.currentPlayerIndex ? 'current' : ''} ${!player.alive ? 'dead' : ''}`;
                    
                    const hpPercentage = (player.hp / player.maxHp) * 100;
                    let hpClass = '';
                    if (hpPercentage <= 25) hpClass = 'critical';
                    else if (hpPercentage <= 50) hpClass = 'low';
                    
                    playerCard.innerHTML = `
                        <div class="player-name">${player.name}</div>
                        <div class="player-role ${player.role}">${this.roleNames[player.role] || 'æœªçŸ¥'}</div>
                        <div style="font-size: 0.8rem; color: #666;">${player.character ? player.character.name : 'æœªé€‰æ‹©æ­¦å°†'}</div>
                        <div class="hp-bar">
                            <div class="hp-fill ${hpClass}" style="width: ${hpPercentage}%"></div>
                        </div>
                        <div class="player-stats">
                            <span>ä½“åŠ›: ${player.hp}/${player.maxHp}</span>
                            <span>æ‰‹ç‰Œ: ${player.handCards.length}</span>
                        </div>
                    `;
                    
                    container.appendChild(playerCard);
                });
            }

            updateHandCardsDisplay() {
                const container = document.getElementById('handCards');
                container.innerHTML = '';
                
                if (this.gameStarted && !this.players[this.currentPlayerIndex].isAI) {
                    const currentPlayer = this.players[this.currentPlayerIndex];
                    
                    currentPlayer.handCards.forEach(card => {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'card';
                        cardElement.onclick = () => this.selectCard(cardElement, card);
                        
                        cardElement.innerHTML = `
                            <div class="card-name">${card.name}</div>
                            <div class="card-type">${card.type}</div>
                            <div style="font-size: 0.7rem;">${card.suit}${card.value}</div>
                        `;
                        
                        container.appendChild(cardElement);
                    });
                }
            }

            updateButtonStates() {
                const gameRunning = this.gameStarted && this.gamePhase === 'play' && !this.players[this.currentPlayerIndex].isAI;
                
                document.getElementById('endTurnBtn').disabled = !gameRunning;
                document.getElementById('attackBtn').disabled = !gameRunning;
                document.getElementById('dodgeBtn').disabled = !gameRunning;
                document.getElementById('peachBtn').disabled = !gameRunning;
                document.getElementById('equipBtn').disabled = !gameRunning;
            }

            getPhaseText() {
                const phases = {
                    'prepare': 'å‡†å¤‡é˜¶æ®µ',
                    'draw': 'æ‘¸ç‰Œé˜¶æ®µ',
                    'play': 'å‡ºç‰Œé˜¶æ®µ',
                    'discard': 'å¼ƒç‰Œé˜¶æ®µ',
                    'end': 'ç»“æŸé˜¶æ®µ'
                };
                return phases[this.gamePhase] || 'æœªçŸ¥é˜¶æ®µ';
            }

            addLogEntry(message, important = false) {
                this.gameLog.push({ message, important, timestamp: new Date() });
                
                const logContainer = document.getElementById('gameLog');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${important ? 'important' : ''}`;
                logEntry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // é™åˆ¶æ—¥å¿—æ¡ç›®æ•°é‡
                if (this.gameLog.length > 50) {
                    this.gameLog.shift();
                    if (logContainer.firstChild) {
                        logContainer.removeChild(logContainer.firstChild);
                    }
                }
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        const threeKingdoms = new ThreeKingdomsGame();
    </script>
</body>
</html>