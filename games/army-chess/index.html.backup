<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å†›æ£‹æ¸¸æˆ - å†›äº‹ç­–ç•¥å¯¹æˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #2d3436 0%, #636e72 50%, #b2bec3 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            max-width: 900px;
            width: 100%;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-title {
            font-size: 2.5em;
            font-weight: 700;
            color: #2d3436;
            margin-bottom: 10px;
        }

        .game-subtitle {
            color: #636e72;
            font-size: 1.1em;
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
            font-weight: bold;
            color: #2d3436;
        }

        .info-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .red-info {
            color: #e74c3c;
        }

        .blue-info {
            color: #3498db;
        }

        .turn-info {
            color: #27ae60;
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            grid-template-rows: repeat(12, 50px);
            gap: 2px;
            background: #34495e;
            padding: 10px;
            border-radius: 10px;
        }

        .chess-cell {
            background: #ecf0f1;
            border: 1px solid #bdc3c7;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: bold;
            position: relative;
        }

        .chess-cell:hover {
            background: #d5dbdb;
        }

        .chess-cell.selected {
            background: #f39c12;
            color: white;
        }

        .chess-cell.possible-move {
            background: #2ecc71;
            color: white;
        }

        .chess-cell.red-camp {
            background: #e74c3c;
            color: white;
        }

        .chess-cell.blue-camp {
            background: #3498db;
            color: white;
        }

        .chess-cell.railway {
            background: #95a5a6;
        }

        .chess-cell.headquarters {
            background: #9b59b6;
            color: white;
            font-weight: bold;
        }

        .chess-piece {
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            line-height: 1.2;
            padding: 2px;
        }

        .red-piece {
            color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 4px;
        }

        .blue-piece {
            color: #3498db;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 4px;
        }

        .game-controls {
            text-align: center;
            margin: 20px 0;
        }

        .control-button {
            padding: 12px 25px;
            background: #2d3436;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            background: #636e72;
            transform: translateY(-2px);
        }

        .control-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .message {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
            display: none;
        }

        .message.show {
            display: block;
        }

        .message.info {
            background: #e8f4f8;
            color: #2980b9;
        }

        .message.success {
            background: #d5f4e6;
            color: #00b894;
        }

        .message.error {
            background: #ffeaa7;
            color: #e17055;
        }

        .piece-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .army-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
        }

        .army-info h3 {
            margin-bottom: 10px;
            text-align: center;
        }

        .red-army h3 {
            color: #e74c3c;
        }

        .blue-army h3 {
            color: #3498db;
        }

        .piece-count {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            font-size: 12px;
        }

        .piece-item {
            text-align: center;
            padding: 5px;
            background: white;
            border-radius: 5px;
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 20px;
                margin: 10px;
            }

            .chess-board {
                grid-template-columns: repeat(5, 45px);
                grid-template-rows: repeat(12, 38px);
            }

            .chess-cell {
                font-size: 10px;
            }

            .chess-piece {
                font-size: 8px;
            }

            .piece-info {
                grid-template-columns: 1fr;
            }

            .game-title {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">ğŸ–ï¸ å†›æ£‹å¯¹æˆ˜</h1>
            <p class="game-subtitle">å†›äº‹ç­–ç•¥æ£‹ç±»æ¸¸æˆ - è¿ç­¹å¸·å¹„ï¼Œå†³èƒœåƒé‡Œï¼</p>
        </div>

        <div class="game-info">
            <div class="info-item red-info">
                çº¢å†›å‰©ä½™: <span id="redCount">25</span>
            </div>
            <div class="info-item turn-info">
                å½“å‰å›åˆ: <span id="currentTurn">çº¢å†›</span>
            </div>
            <div class="info-item blue-info">
                è“å†›å‰©ä½™: <span id="blueCount">25</span>
            </div>
        </div>

        <div class="board-container">
            <div class="chess-board" id="chessBoard">
                <!-- æ£‹ç›˜åŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="message" id="message"></div>

        <div class="piece-info">
            <div class="army-info red-army">
                <h3>ğŸ”´ çº¢å†›å…µåŠ›</h3>
                <div class="piece-count" id="redPieceCount">
                    <!-- çº¢å†›æ£‹å­ç»Ÿè®¡ -->
                </div>
            </div>
            <div class="army-info blue-army">
                <h3>ğŸ”µ è“å†›å…µåŠ›</h3>
                <div class="piece-count" id="bluePieceCount">
                    <!-- è“å†›æ£‹å­ç»Ÿè®¡ -->
                </div>
            </div>
        </div>

        <div class="game-controls">
            <button class="control-button" id="startButton">å¼€å§‹æ¸¸æˆ</button>
            <button class="control-button" id="resetButton">é‡æ–°å¼€å§‹</button>
            <button class="control-button" id="hintButton">æç¤º</button>
        </div>
    </div>

    <script>
        class ArmyChess {
            constructor() {
                this.board = [];
                this.currentPlayer = 'red';
                this.selectedPiece = null;
                this.gameStarted = false;
                this.gameEnded = false;
                
                // å†›æ£‹æ£‹å­å®šä¹‰
                this.pieces = {
                    'å¸ä»¤': { rank: 1, count: 1, symbol: 'å¸' },
                    'å†›é•¿': { rank: 2, count: 1, symbol: 'å†›' },
                    'å¸ˆé•¿': { rank: 3, count: 2, symbol: 'å¸ˆ' },
                    'æ—…é•¿': { rank: 4, count: 2, symbol: 'æ—…' },
                    'å›¢é•¿': { rank: 5, count: 2, symbol: 'å›¢' },
                    'è¥é•¿': { rank: 6, count: 2, symbol: 'è¥' },
                    'è¿é•¿': { rank: 7, count: 3, symbol: 'è¿' },
                    'æ’é•¿': { rank: 8, count: 3, symbol: 'æ’' },
                    'å·¥å…µ': { rank: 9, count: 3, symbol: 'å·¥' },
                    'åœ°é›·': { rank: 10, count: 3, symbol: 'é›·' },
                    'ç‚¸å¼¹': { rank: 11, count: 2, symbol: 'ç‚¸' },
                    'å†›æ——': { rank: 12, count: 1, symbol: 'æ——' }
                };
                
                this.initBoard();
                this.bindEvents();
                this.renderBoard();
                this.updatePieceCount();
            }

            initBoard() {
                // åˆå§‹åŒ–12x5çš„æ£‹ç›˜
                this.board = Array(12).fill(null).map(() => Array(5).fill(null));
                
                // è®¾ç½®ç‰¹æ®Šåœ°å½¢
                this.setupTerrain();
                
                // æ”¾ç½®æ£‹å­
                this.setupPieces();
            }

            setupTerrain() {
                // è®¾ç½®é“è·¯çº¿ï¼ˆå¯ä»¥å¿«é€Ÿç§»åŠ¨ï¼‰
                for (let col = 1; col < 4; col++) {
                    this.board[1][col] = { type: 'railway' };
                    this.board[5][col] = { type: 'railway' };
                    this.board[6][col] = { type: 'railway' };
                    this.board[10][col] = { type: 'railway' };
                }
                
                // è®¾ç½®å¤§æœ¬è¥
                this.board[0][1] = { type: 'headquarters', camp: 'red' };
                this.board[0][3] = { type: 'headquarters', camp: 'red' };
                this.board[11][1] = { type: 'headquarters', camp: 'blue' };
                this.board[11][3] = { type: 'headquarters', camp: 'blue' };
            }

            setupPieces() {
                // éšæœºå¸ƒç½®çº¢å†›æ£‹å­ï¼ˆä¸‹æ–¹ï¼‰
                this.placePiecesRandomly('red', 7, 11);
                
                // éšæœºå¸ƒç½®è“å†›æ£‹å­ï¼ˆä¸Šæ–¹ï¼‰
                this.placePiecesRandomly('blue', 0, 4);
            }

            placePiecesRandomly(color, startRow, endRow) {
                const availablePositions = [];
                
                // æ”¶é›†å¯ç”¨ä½ç½®
                for (let row = startRow; row <= endRow; row++) {
                    for (let col = 0; col < 5; col++) {
                        if (!this.board[row][col] || 
                            (this.board[row][col].type !== 'headquarters')) {
                            availablePositions.push([row, col]);
                        }
                    }
                }
                
                // åˆ›å»ºæ£‹å­åˆ—è¡¨
                const pieceList = [];
                Object.entries(this.pieces).forEach(([name, info]) => {
                    for (let i = 0; i < info.count; i++) {
                        pieceList.push({
                            name,
                            rank: info.rank,
                            symbol: info.symbol,
                            color,
                            hidden: true // å†›æ£‹ä¸­æ£‹å­æ˜¯æš—æ£‹
                        });
                    }
                });
                
                // éšæœºæ”¾ç½®
                for (let i = 0; i < pieceList.length && availablePositions.length > 0; i++) {
                    const randomIndex = Math.floor(Math.random() * availablePositions.length);
                    const [row, col] = availablePositions[randomIndex];
                    
                    this.board[row][col] = {
                        ...this.board[row][col],
                        piece: pieceList[i]
                    };
                    
                    availablePositions.splice(randomIndex, 1);
                }
                
                // ç‰¹æ®Šå¤„ç†ï¼šå†›æ——å’Œåœ°é›·åªèƒ½æ”¾åœ¨åæ’
                this.adjustSpecialPieces(color, startRow, endRow);
            }

            adjustSpecialPieces(color, startRow, endRow) {
                // ç¡®ä¿å†›æ——åœ¨å¤§æœ¬è¥ï¼Œåœ°é›·åœ¨åä¸¤æ’
                const flagRow = color === 'red' ? 11 : 0;
                const mineRows = color === 'red' ? [10, 11] : [0, 1];
                
                // æ‰¾åˆ°å†›æ——å¹¶ç§»åˆ°å¤§æœ¬è¥
                for (let row = startRow; row <= endRow; row++) {
                    for (let col = 0; col < 5; col++) {
                        if (this.board[row][col]?.piece?.name === 'å†›æ——') {
                            const piece = this.board[row][col].piece;
                            this.board[row][col] = { ...this.board[row][col], piece: null };
                            
                            // æ”¾åˆ°å¤§æœ¬è¥
                            const flagPositions = [[flagRow, 1], [flagRow, 3]];
                            const randomFlag = flagPositions[Math.floor(Math.random() * 2)];
                            this.board[randomFlag[0]][randomFlag[1]] = {
                                ...this.board[randomFlag[0]][randomFlag[1]],
                                piece
                            };
                            break;
                        }
                    }
                }
            }

            bindEvents() {
                document.getElementById('startButton').addEventListener('click', () => {
                    this.startGame();
                });

                document.getElementById('resetButton').addEventListener('click', () => {
                    this.resetGame();
                });

                document.getElementById('hintButton').addEventListener('click', () => {
                    this.showHint();
                });

                document.getElementById('chessBoard').addEventListener('click', (e) => {
                    if (e.target.classList.contains('chess-cell')) {
                        const row = parseInt(e.target.dataset.row);
                        const col = parseInt(e.target.dataset.col);
                        this.handleCellClick(row, col);
                    }
                });
            }

            startGame() {
                this.gameStarted = true;
                this.gameEnded = false;
                this.currentPlayer = 'red';
                document.getElementById('startButton').style.display = 'none';
                this.showMessage('æ¸¸æˆå¼€å§‹ï¼çº¢å†›å…ˆè¡Œ', 'info');
                this.renderBoard();
            }

            resetGame() {
                this.gameStarted = false;
                this.gameEnded = false;
                this.selectedPiece = null;
                this.currentPlayer = 'red';
                this.initBoard();
                this.renderBoard();
                this.updatePieceCount();
                document.getElementById('startButton').style.display = 'inline-block';
                this.hideMessage();
            }

            handleCellClick(row, col) {
                if (!this.gameStarted || this.gameEnded) return;

                const cell = this.board[row][col];
                
                if (this.selectedPiece) {
                    // å°è¯•ç§»åŠ¨æ£‹å­
                    this.attemptMove(this.selectedPiece.row, this.selectedPiece.col, row, col);
                } else if (cell?.piece && cell.piece.color === this.currentPlayer) {
                    // é€‰æ‹©æ£‹å­
                    this.selectPiece(row, col);
                }
            }

            selectPiece(row, col) {
                this.selectedPiece = { row, col };
                this.renderBoard();
                this.showPossibleMoves(row, col);
            }

            showPossibleMoves(row, col) {
                const piece = this.board[row][col]?.piece;
                if (!piece) return;

                const moves = this.getPossibleMoves(row, col);
                moves.forEach(([r, c]) => {
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cell.classList.add('possible-move');
                    }
                });
            }

            getPossibleMoves(row, col) {
                const piece = this.board[row][col]?.piece;
                if (!piece) return [];

                const moves = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // ä¸Šä¸‹å·¦å³

                if (piece.name === 'å·¥å…µ') {
                    // å·¥å…µå¯ä»¥æ²¿é“è·¯çº¿ç§»åŠ¨
                    return this.getEngineerMoves(row, col);
                }

                // æ™®é€šæ£‹å­åªèƒ½ç§»åŠ¨ä¸€æ ¼
                directions.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (this.isValidPosition(newRow, newCol)) {
                        const targetCell = this.board[newRow][newCol];
                        
                        // å¯ä»¥ç§»åŠ¨åˆ°ç©ºä½æˆ–æ•Œæ–¹æ£‹å­ä½ç½®
                        if (!targetCell?.piece || 
                            targetCell.piece.color !== piece.color) {
                            moves.push([newRow, newCol]);
                        }
                    }
                });

                return moves;
            }

            getEngineerMoves(row, col) {
                // å·¥å…µç‰¹æ®Šç§»åŠ¨è§„åˆ™ï¼ˆç®€åŒ–ç‰ˆï¼‰
                const moves = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                directions.forEach(([dr, dc]) => {
                    let newRow = row + dr;
                    let newCol = col + dc;
                    
                    while (this.isValidPosition(newRow, newCol)) {
                        const targetCell = this.board[newRow][newCol];
                        
                        if (!targetCell?.piece) {
                            moves.push([newRow, newCol]);
                        } else if (targetCell.piece.color !== this.currentPlayer) {
                            moves.push([newRow, newCol]);
                            break;
                        } else {
                            break;
                        }
                        
                        newRow += dr;
                        newCol += dc;
                    }
                });

                return moves;
            }

            attemptMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol]?.piece;
                const target = this.board[toRow][toCol];

                if (!piece) return;

                const possibleMoves = this.getPossibleMoves(fromRow, fromCol);
                const isValidMove = possibleMoves.some(([r, c]) => r === toRow && c === toCol);

                if (!isValidMove) {
                    this.showMessage('æ— æ•ˆç§»åŠ¨ï¼', 'error');
                    this.clearSelection();
                    return;
                }

                // å¤„ç†æˆ˜æ–—
                if (target?.piece) {
                    const battleResult = this.resolveBattle(piece, target.piece);
                    this.showMessage(battleResult.message, battleResult.type);
                    
                    if (battleResult.winner === piece) {
                        this.movePiece(fromRow, fromCol, toRow, toCol);
                    } else if (battleResult.winner === target.piece) {
                        // æ”»å‡»æ–¹å¤±è´¥ï¼Œç§»é™¤æ”»å‡»æ–¹æ£‹å­
                        this.board[fromRow][fromCol] = { ...this.board[fromRow][fromCol], piece: null };
                        this.revealPiece(toRow, toCol);
                    } else {
                        // åŒå½’äºå°½
                        this.board[fromRow][fromCol] = { ...this.board[fromRow][fromCol], piece: null };
                        this.board[toRow][toCol] = { ...this.board[toRow][toCol], piece: null };
                    }
                } else {
                    this.movePiece(fromRow, fromCol, toRow, toCol);
                    this.showMessage(`${piece.name}ç§»åŠ¨åˆ°æ–°ä½ç½®`, 'info');
                }

                this.clearSelection();
                this.checkGameEnd();
                this.switchPlayer();
                this.updatePieceCount();
                this.renderBoard();
            }

            movePiece(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol].piece;
                this.board[toRow][toCol] = { ...this.board[toRow][toCol], piece };
                this.board[fromRow][fromCol] = { ...this.board[fromRow][fromCol], piece: null };
                this.revealPiece(toRow, toCol);
            }

            revealPiece(row, col) {
                const piece = this.board[row][col]?.piece;
                if (piece) {
                    piece.hidden = false;
                }
            }

            resolveBattle(attacker, defender) {
                // å†›æ£‹æˆ˜æ–—è§„åˆ™
                this.revealPiece(this.selectedPiece.row, this.selectedPiece.col);
                
                // ç‰¹æ®Šè§„åˆ™
                if (defender.name === 'åœ°é›·') {
                    if (attacker.name === 'å·¥å…µ') {
                        return {
                            winner: attacker,
                            message: 'å·¥å…µæˆåŠŸæ’é›·ï¼',
                            type: 'success'
                        };
                    } else {
                        return {
                            winner: defender,
                            message: `${attacker.name}è§¦é›·é˜µäº¡ï¼`,
                            type: 'error'
                        };
                    }
                }

                if (defender.name === 'å†›æ——') {
                    return {
                        winner: attacker,
                        message: `${attacker.name}å¤ºå–å†›æ——ï¼æ¸¸æˆç»“æŸï¼`,
                        type: 'success'
                    };
                }

                if (attacker.name === 'ç‚¸å¼¹') {
                    return {
                        winner: null,
                        message: 'ç‚¸å¼¹çˆ†ç‚¸ï¼åŒå½’äºå°½ï¼',
                        type: 'info'
                    };
                }

                if (defender.name === 'ç‚¸å¼¹') {
                    return {
                        winner: null,
                        message: 'è§¦å‘ç‚¸å¼¹ï¼åŒå½’äºå°½ï¼',
                        type: 'info'
                    };
                }

                // æŒ‰å†›è¡”æ¯”è¾ƒ
                if (attacker.rank < defender.rank) {
                    return {
                        winner: attacker,
                        message: `${attacker.name}å‡»è´¥${defender.name}ï¼`,
                        type: 'success'
                    };
                } else if (attacker.rank > defender.rank) {
                    return {
                        winner: defender,
                        message: `${defender.name}å‡»è´¥${attacker.name}ï¼`,
                        type: 'error'
                    };
                } else {
                    return {
                        winner: null,
                        message: `${attacker.name}ä¸${defender.name}åŒå½’äºå°½ï¼`,
                        type: 'info'
                    };
                }
            }

            clearSelection() {
                this.selectedPiece = null;
                this.renderBoard();
            }

            switchPlayer() {
                this.currentPlayer = this.currentPlayer === 'red' ? 'blue' : 'red';
                document.getElementById('currentTurn').textContent = 
                    this.currentPlayer === 'red' ? 'çº¢å†›' : 'è“å†›';
            }

            checkGameEnd() {
                let redFlag = false, blueFlag = false;
                let redPieces = 0, bluePieces = 0;

                for (let row = 0; row < 12; row++) {
                    for (let col = 0; col < 5; col++) {
                        const piece = this.board[row][col]?.piece;
                        if (piece) {
                            if (piece.color === 'red') {
                                redPieces++;
                                if (piece.name === 'å†›æ——') redFlag = true;
                            } else {
                                bluePieces++;
                                if (piece.name === 'å†›æ——') blueFlag = true;
                            }
                        }
                    }
                }

                if (!redFlag) {
                    this.endGame('è“å†›èƒœåˆ©ï¼å¤ºå–çº¢å†›å†›æ——ï¼');
                } else if (!blueFlag) {
                    this.endGame('çº¢å†›èƒœåˆ©ï¼å¤ºå–è“å†›å†›æ——ï¼');
                } else if (redPieces <= 1) {
                    this.endGame('è“å†›èƒœåˆ©ï¼çº¢å†›æ— å­å¯åŠ¨ï¼');
                } else if (bluePieces <= 1) {
                    this.endGame('çº¢å†›èƒœåˆ©ï¼è“å†›æ— å­å¯åŠ¨ï¼');
                }
            }

            endGame(message) {
                this.gameEnded = true;
                this.showMessage(message, 'success');
                
                // æ˜¾ç¤ºæ‰€æœ‰æ£‹å­
                for (let row = 0; row < 12; row++) {
                    for (let col = 0; col < 5; col++) {
                        const piece = this.board[row][col]?.piece;
                        if (piece) {
                            piece.hidden = false;
                        }
                    }
                }
                
                this.renderBoard();
            }

            showHint() {
                if (!this.gameStarted || this.gameEnded) return;

                const currentPieces = [];
                for (let row = 0; row < 12; row++) {
                    for (let col = 0; col < 5; col++) {
                        const piece = this.board[row][col]?.piece;
                        if (piece && piece.color === this.currentPlayer) {
                            const moves = this.getPossibleMoves(row, col);
                            if (moves.length > 0) {
                                currentPieces.push({ row, col, moves: moves.length });
                            }
                        }
                    }
                }

                if (currentPieces.length > 0) {
                    // å»ºè®®ç§»åŠ¨æœ€å¤šå¯èƒ½ç§»åŠ¨çš„æ£‹å­
                    const bestPiece = currentPieces.reduce((best, current) => 
                        current.moves > best.moves ? current : best
                    );
                    
                    this.selectPiece(bestPiece.row, bestPiece.col);
                    this.showMessage(`å»ºè®®ç§»åŠ¨ä½ç½® (${bestPiece.row}, ${bestPiece.col}) çš„æ£‹å­`, 'info');
                } else {
                    this.showMessage('æ— å¯ç§»åŠ¨æ£‹å­ï¼', 'error');
                }
            }

            isValidPosition(row, col) {
                return row >= 0 && row < 12 && col >= 0 && col < 5;
            }

            renderBoard() {
                const board = document.getElementById('chessBoard');
                board.innerHTML = '';

                for (let row = 0; row < 12; row++) {
                    for (let col = 0; col < 5; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'chess-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;

                        const cellData = this.board[row][col];
                        
                        // è®¾ç½®åœ°å½¢æ ·å¼
                        if (cellData?.type === 'railway') {
                            cell.classList.add('railway');
                        } else if (cellData?.type === 'headquarters') {
                            cell.classList.add('headquarters');
                            if (cellData.camp) {
                                cell.classList.add(`${cellData.camp}-camp`);
                            }
                        }

                        // æ˜¾ç¤ºæ£‹å­
                        if (cellData?.piece) {
                            const piece = cellData.piece;
                            const pieceDiv = document.createElement('div');
                            pieceDiv.className = `chess-piece ${piece.color}-piece`;
                            
                            if (piece.hidden && this.gameStarted && !this.gameEnded) {
                                pieceDiv.textContent = '?';
                            } else {
                                pieceDiv.textContent = piece.symbol;
                            }
                            
                            cell.appendChild(pieceDiv);
                        }

                        // é«˜äº®é€‰ä¸­çš„æ£‹å­
                        if (this.selectedPiece && 
                            this.selectedPiece.row === row && 
                            this.selectedPiece.col === col) {
                            cell.classList.add('selected');
                        }

                        board.appendChild(cell);
                    }
                }
            }

            updatePieceCount() {
                let redCount = 0, blueCount = 0;
                const redPieces = {}, bluePieces = {};

                for (let row = 0; row < 12; row++) {
                    for (let col = 0; col < 5; col++) {
                        const piece = this.board[row][col]?.piece;
                        if (piece) {
                            if (piece.color === 'red') {
                                redCount++;
                                redPieces[piece.name] = (redPieces[piece.name] || 0) + 1;
                            } else {
                                blueCount++;
                                bluePieces[piece.name] = (bluePieces[piece.name] || 0) + 1;
                            }
                        }
                    }
                }

                document.getElementById('redCount').textContent = redCount;
                document.getElementById('blueCount').textContent = blueCount;

                this.updatePieceCountDisplay('redPieceCount', redPieces);
                this.updatePieceCountDisplay('bluePieceCount', bluePieces);
            }

            updatePieceCountDisplay(elementId, pieceCount) {
                const container = document.getElementById(elementId);
                container.innerHTML = '';

                Object.entries(this.pieces).forEach(([name, info]) => {
                    const count = pieceCount[name] || 0;
                    const item = document.createElement('div');
                    item.className = 'piece-item';
                    item.innerHTML = `${info.symbol}<br>${count}`;
                    container.appendChild(item);
                });
            }

            showMessage(text, type) {
                const message = document.getElementById('message');
                message.textContent = text;
                message.className = `message ${type} show`;
            }

            hideMessage() {
                const message = document.getElementById('message');
                message.classList.remove('show');
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        window.addEventListener('load', () => {
            new ArmyChess();
        });
    </script>
</body>
</html>